##############################################################################
###########################      (1). Header       ###########################
##############################################################################

#include <stdio.h>    // printf, fputs, fgets 입출력 관련 header
#include <cstring>    // strncpy, strcmp, strncmp(str1, str2, 3)
#include <string.h>   // memset
                          -- struct sock_addr_in sock_addr;
                          -- memset(&sock_addr, 0, sizeof(sock_addr); --> 구조체에서는 이렇게 memset 으로 초기화 해주어야 한다.
                                                                      --> 구조체는 메모리를 memalloc으로 ** 할당하는 것이 아니기 때문에, free 할 필요 ** 가 없다
                                                                      [스택 할당]
                                                                        > struct sock_addr_in sock_addr;
                                                                        > memset(&sock_addr, 0, sizeof(sock_addr);
                                                                      [힙 할당] ( 보통 class ) 에서 함
                                                                        > struct sock_addr_in* sock_addr = (sock_addr_in*) malloc(sizeof(struct sock_addr_in));
                                                                        > memset(sock_addr, 0, sizeof(struct sock_addr_in));
                                                                        > free(sock_addr);

                                                                      --> 구조체는 보통 [힙] (X) [스택] (O) 에 저장되는 경우가 많다.

#include <cstdlib>    // exit
#include <unistd.h>   // read, write, close 파일 디스크립터와 관련 헤더
#include <string>     // string 클래스를 사용하기 위함

#include <pthread.h>  // posix에서 pthread 를 사용하기 위한 헤더
#include <sys/socket.h>
#include <arpa/inet.h>  // struct sock_addr_in 을 사용하기 위한 헤더

##############################################################################
###########################      (2). 문자열       ###########################
##############################################################################

> char* msg = "send_msg"; --> 문자열 포인터
                          --> 매개변수 ( char* msg )
> char msg[BUF_SIZE] = "send_msg" --> 문자(char) 배열
                                  --> msg[3] = 'd';
                                  --> 매개변수 ( char msg[] )
                                  --> 할당을 해주었으면 : memset(msg, 0, BUF_SIZE); 해주어야 한다 >> 안 그러면 쓰레기 값이 저장


##############################################################################
###########################      (3). socket       ###########################
##############################################################################

          [서버]                                      [클라이언트]
          (1). socket 생성                            (1). socket 생성
          (2). bind : 소켓 주소 할당
          (3). listen : 소켓 연결 대기
          (4). accept : 연결 혀용           <-----     (2). connect : 연결 요청
          (5). send / recv : 데이터 송수신   <---->    (3). send / recv : 데이터 송수신
          (6). close : 소켓 종료                       (4). close : 소켓 종료


[서버]
(1). socket 생성 : int socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                   // 성공 : ** fd ( 파일 디스크립터 ) ** , 실패 : (-1)
                   // AF_INET : 프로토콜 패밀리, IPV4 를 사용
                   // SOCK_STREAM : 소켓 데이터 type
                   // IPPROTO_TCP : tcp, IPPROTO_UDP : udp

(2). bind : 소켓 주소 할당

// 서버 정보
const char* server_ip = "127.0.0.1" ( local ip 주소 )
const char* server_port = "8080";

struct sockaddr_in sock_addr;
memset(&sock_addr, 0, sizeof(sock_addr);

sock_addr.sin_family = AF_INET;
sock_addr.sin_addr.s_addr = htonl(INADDR_ANY); / inet_addr(server_ip);
sock_addr.sin_port = htons(atoi(server_port));

int ret = bind(serv_sock,(struct sockaddr*) &sock_addr, sizeof(sock_addr));
          // serv_sock : fd ( 파일 디스크립터 )
          // 실패 : -1;

(3). listen : 소켓 연결 대기
int ret = listen(serv_sock, MAX_CLIENT);
          // serv_sock : fd ( 파일 디스크립터 )
          // MAX_CLIENT : 연결 대기 큐의 크기
                        : 이 대기 큐의 크기만큼 클라이언트 연결 대기
          // 실패 : -1;

(4). accept : 연결 허용
            : 클라이언트 정보를 받아옴

// 클라이언트 정보
struct sockaddr_in clnt_addr;
int clnt_addr_size = sizeof(clnt_addr);

int ** clnt_sock ** = accept(serv_sock, (struct sockaddr* ) &clnt_addr, (socklen_t*) &clnt_addr_size)); --> ** 클라이언트 정보를 받아오는 함수
                                                                                                        --> ** return 값은 클라이언트 파일 디스크립터 ( fd )
                    // 성공 : 클라이언트 파일 디스크립터 (fd), 실패 : -1;

(5). send / recv : 데이터 송수신
send

##############################################################################
###########################    (4). socket 구조     ###########################
##############################################################################
https://github.com/shpark0308/c_study_develop/assets/60208434/57c944d0-2fc0-44f4-b7d8-a35007054823
https://github.com/shpark0308/c_study_develop/assets/60208434/fb0232d1-8ad2-4ffe-a084-ae27eea1584d



##############################################################################
###########################      (3). socket       ###########################
##############################################################################


