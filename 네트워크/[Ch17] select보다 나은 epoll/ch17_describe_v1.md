ⅠⅡⅢⅣ1️⃣2️⃣3️⃣4️⃣✅🔯

### Ⅰ. I/O 멀티플렉싱
#### 1️⃣ select
✅ 소개
- FD_SET ( fd 집합체 ) 에서 **하나의 fd 라도 변화가 있을 경우**, 블로킹 / 논블로킹 됨
- 싱글 스레드로 다중 I/O 를 처리

🔯 과정

(1) [ 프로세스 ] → [ 커널 ] : 프로세스가 ( 커널의 상황 )을 지속적으로 확인
``` cpp
while(true)
{
  cpy_reads = temp_reads;   // fd_set 복사

  int fd_num = select( fd_max + 1, &cpy_reads, 0, 0, &timeout );
}
```
- FD_SET 에 있는 모든 fd 목록 전체를 체크해야 한다.
- 원본 fd_set 이 아니라, 복사본을 전달해야한다.
  - select() 함수가 실행 ( 블로킹 ) 하는 도중, 파일 디스크럽터 집합 ( 원본 ) 이 변할 수 있음

(2) [ 커널 ] → [ 프로세스 ]
- 이에 대응

(3). 변화 발생
- fd 가 할당 받은 (( 커널 버퍼 )) 에 데이터 복사

✅ 장점
- 모든 운영체제에서 사용 가능 ( OS 에 종속적이지 않음 )
- 싱글 스레드에서 다중 I/O 처리

✅ 단점
- FD_SET 에 있는 모든 Fd 에 대해서 I/O 할 준비가 되었는지 확인
  - 비 효율적
  - 느리다
- fd_set 의 원본이 아니라 복사본을 전달해야하는 번거로움
- 관리할 수 있는 fd 의 갯수 한계 ( 1024개 )

&nbsp; &nbsp; &nbsp;**⇨ epoll ( select() 함수의 한계점 극복 )**
<br/>

#### 2️⃣ poll
✅ 소개
- select() 의 개선 방안
- select 에 비해 관리할 수 있는 fd 의 갯수가 증가함

✅ 단점
- 일부 UNIX ( 리눅스 ) 시스템에서 지원 안함
<br>

#### 3️⃣ epoll
✅ 소개
- select() 함수의 한계점 극복
- 커널 레벨의 멀티 플렉싱 지원

🔯 과정

(1). [ 프로세스 ] → [ 커널 ]
- 관찰 대상의 fd 를 전달 ( epoll_ctl )

(2) [ 커널 ] → [ 프로세스 ]
- 변경 사항이 있는 fd 에 대해서만 알림

✅ 장점
- select() 와 다르게, 모든 fd 가 아닌, 변경사항이 있는 fd 에 대해서만 처리를 하면 된다.
- 관리할 수 있는 fd 의 갯수가 증가하였다.
``` bash
[shpark0308@localhost fd]$ cat /proc/sys/fs/epoll/max_user_watches
26839449
```

✅ 단점
- 운영체제에 종속적
  - 리눅스 : epoll
  - 윈도우 : IOCP

✅ 이벤트
|이벤트|설명|
|:------:|:---:|
|EPOLLIN|데이터 수신(입력)|
|EPOLLHUP|연결 종료 / 파일 디스크립터 닫힘|
|EPOLLET|엣지 트리거 모드|

🔯 select VS epoll

![image](https://github.com/shpark0308/c_study_develop/assets/60208434/4465d502-e003-44d1-9344-4e1e122775ed)
<br/>

### Ⅱ. Trigger

![image](https://github.com/shpark0308/c_study_develop/assets/60208434/d11dafab-9d89-46b1-ab3e-e743a462b98d)

#### 1️⃣ 엣지 트리거

![image](https://github.com/shpark0308/c_study_develop/assets/60208434/eac4db55-5d60-4f2e-8bb4-c7b5309d8181)

✅ 소개
- 데이터(fd)의 변화가 있을 시 / 이벤트 발생할 때 ⇨ **알림** 발생

✅ 소켓
- 이벤트
  - 소켓 버퍼에 데이터가 들어오는 순간 ( 데이터 도착 ( recv ) )
  - 연결 상태 변경
 
✅ 적합한 상황

(1). 빠른 응답이 필요한 경우
- 데이터 변경, 연결 상태 변경 등의 이벤트 발생 시, 즉각적 반응

✅ 적합하지 않은 상황

(1). 데이터의 변화가 잦을 경우
- 네트워크 부하 증가

(2). 특정 엣지만 처리 해야하는 경우
- 데이터 처리량 증가

🔯 서버

(1). **Non-Blocking I/O 소켓**으로 변경
``` cpp
int flag = fcntl( fd, F_GETFL, 0 );      // 블로킹 / 논블로킹 여부 확인
fcntl(fd, F_SETFL, flag | O_NONBLOCK );
```
- 모든 이벤트 수신
  - 동일한 이벤트에 대해서 처리하지 못하는 엣지 트리거에서, **이벤트 누락을 방지**하기 위함
- 충분한 데이터 수신
  - 수신 데이터 버퍼 [ ] 가 작을 경우, 데이터 양에 따라서, 블로킹이 발생

(2). 충분한 양의 버퍼
- 수신 데이터의 버퍼가 작을 경우, 블로킹 발생 가능성 존재

(3). 소켓 버퍼의 Empty 여부
- errno 변수를 참조하여 EAGAIN 값이면, 버퍼가 빈 상태
<br/>

⚠ EAGAIN
- POSIX 에서 정의된 에러 코드
- "다시 시도하라" 의 의미
- 나중에 성공할 때까지 작업을 반복
---
(1) 비동기 I/O, 논 블로킹 I/O 에서 사용
  - 소켓에서 데이터를 RD / WR 하려고 할 때, 소켓 버퍼가 비어있거나 데이터를 받을 수 있는 공간이 없을 경우, 발생
  - 시스템 콜이 블록되지 않은 상태에서 리소스를 사용할 수 없는 경우 사용

(2) 시그널 처리
- signal handler 에서 시그널 호출을 수행할 떄, 해당 시그널이 처리되기 전에, 시스템 호출이 중단되는 경우 
<br/>

🔯 판도라
- 데이터의 변화가 잦고
- 동일한 이벤트 ( 데이터 수신 ) 이 많기 떄문에 ( 특정 이벤트가 아님 )

&nbsp; &nbsp; &nbsp; **⇨ (서버) 임에도, 엣지 트리거가 아니라 레벨 트리거를 사용**

🔯 논블로킹 / 비동기 처리 ( 효율적 처리 )

<br/>

#### 2️⃣ 레벨 트리거
✅ 소개
- 데이터의 수준(레벨)이 유지되는 동안, 계속해서 이벤트를 받음
- 이벤트를 받은 이후에도, 동일한 이벤트에 대해서, 감지할 수 있음

✅ 소켓
- 데이터의 수신 버퍼 비어있음 : 계속 이벤트를 받음
- 데이터의 수신 버퍼 비어있지 않음 : 데이터가 도착할 때까지, 기다림

✅ 적합한 상황

(1). 데이터 송수신의 상황이 단순함
- 데이터의 이벤트가 다양하지 않음
- 계속, EPOLLIN ( 데이터 입력 )인 경우

(2). 데이터를 모니터링 함

🔯 서버 & 클라이언트
> 엣지 트리거 : 서버
- 컨트롤 요소가 많음
- 데이터의 송수신이 빈번한 경우
- 즉각적인 이벤트에 대한 처리

> 레벨 트리거 : 클라이언트
- 단순함
- 데이터의 송수신 상황이 다양하지 않음
<br/>

### Ⅲ. C / C++
#### 1️⃣ extern
✅ 소개
- 변수 또는 함수가 다른 소스 파일에 선언되어 있음을 알림

✅ 코드
``` cpp
// file1.cpp
int globalVar;

// file2.cpp
extern int globalVar;
```
- extern int globalVar : 다른 파일 (file1.cpp) 에서 선언된 전역 변수를 사용할 수 있음
<br/>

#### 2️⃣ namespace
✅ 소개
- 이름 공간을 제공하여, 식별자들의 충돌을 방지하고 모듈성을 높임

✅ 코드
```cpp
// header.h
namespace MyNameSpace {
  void myFunction();
}

// source.cpp
#include "header.h"
void MyNamespace::myFunction()
{
}
```
<br/>

#### 3️⃣ class
✅ 소개
- 객체 지향 프로그래밍에서 ( 데이터 )와 ( 해당 데이터를 다루는 함수 ) 를 묶어 하나의 새로운 타입을 정의

✅ 코드
```cpp
class MyClass
{
  public:
    MyClass();           // 생성자
    void myMethod(();    // 멤버 변수
};
```
