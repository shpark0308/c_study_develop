
ⅠⅡⅢⅣ1️⃣2️⃣3️⃣4️⃣✅🔯

### Ⅰ. I/O 멀티플렉싱
#### 1️⃣ select
✅ 소개
- FD_SET ( fd 집합체 ) 에서 **하나의 fd 라도 변화가 있을 경우**, 블로킹 / 논블로킹 됨
- 싱글 스레드로 다중 I/O 를 처리

🔯 과정

(1) [ 프로세스 ] → [ 커널 ] : 프로세스가 ( 커널의 상황 )을 지속적으로 확인
``` cpp
while(true)
{
  cpy_reads = temp_reads;   // fd_set 복사

  int fd_num = select( fd_max + 1, &cpy_reads, 0, 0, &timeout );
}
```
- FD_SET 에 있는 모든 fd 목록 전체를 체크해야 한다.
- 원본 fd_set 이 아니라, 복사본을 전달해야한다.
  - select() 함수가 실행 ( 블로킹 ) 하는 도중, 파일 디스크럽터 집합 ( 원본 ) 이 변할 수 있음

(2) [ 커널 ] → [ 프로세스 ]
- 이에 대응

(3). 변화 발생
- fd 가 할당 받은 (( 커널 버퍼 )) 에 데이터 복사

✅ 장점
- 모든 운영체제에서 사용 가능 ( OS 에 종속적이지 않음 )
- 싱글 스레드에서 다중 I/O 처리

✅ 단점
- FD_SET 에 있는 모든 Fd 에 대해서 I/O 할 준비가 되었는지 확인
  - 비 효율적
  - 느리다
- fd_set 의 원본이 아니라 복사본을 전달해야하는 번거로움
- 관리할 수 있는 fd 의 갯수 한계 ( 1024개 )

&nbsp; &nbsp; &nbsp;**⇨ epoll ( select() 함수의 한계점 극복 )**
<br/>

#### 2️⃣ poll
✅ 소개
- select() 의 개선 방안
- select 에 비해 관리할 수 있는 fd 의 갯수가 증가함

✅ 단점
- 일부 UNIX ( 리눅스 ) 시스템에서 지원 안함
<br>

#### 3️⃣ epoll
✅ 소개
- select() 함수의 한계점 극복
- 커널 레벨의 멀티 플렉싱 지원

🔯 과정

(1). [ 프로세스 ] → [ 커널 ]
- 관찰 대상의 fd 를 전달 ( epoll_ctl )

(2) [ 커널 ] → [ 프로세스 ]
- 변경 사항이 있는 fd 에 대해서만 알림

✅ 장점
- select() 와 다르게, 모든 fd 가 아닌, 변경사항이 있는 fd 에 대해서만 처리를 하면 된다.
- 관리할 수 있는 fd 의 갯수가 증가하였다.
``` bash
[shpark0308@localhost fd]$ cat /proc/sys/fs/epoll/max_user_watches
26839449
```

✅ 단점
- 운영체제에 종속적
  - 리눅스 : epoll
  - 윈도우 : IOCP
 
🔯 select VS epoll

![image](https://github.com/shpark0308/c_study_develop/assets/60208434/4465d502-e003-44d1-9344-4e1e122775ed)

### Ⅱ. Trigger
#### 1️⃣ 레벨 트리거
- 데이터의 수준(레벨)이 유지되는 동안 계속해서 이벤트를 받음
  - 딱히, 데이터 변화가 없으면 어떠한 이벤트를 받는 것인지
- 소켓
- 데이터의 수신 버퍼가 비어있지 않으면 계속해서 이벤트를 받음
- 그럼 수신버퍼가 비어있을 경우는?
- 레벨 트리거는 이벤트를 받은 후에도, 계속해서 이벤트를 감지할 수 있음
  - 데이터의 상태가 변하지 않으면, 계속해서 알림을 줌


- 소켓 버퍼에 데이터가 남아있는 동안에 계쏙 이벤트 발생
- 디폴트:) 레벨 트리거
- [ 서버 ] : 컨트롤 요소가 많고, 데이터 송수신이 빈번한 경우, 엣지 트리거가 유리
- [ 클라이언트 ] : 단순하고 데이터 송수신 상황이 다양하지 않으면 레벨 트리거 방식이 유리

- < 특정 레벨에서 계속 유지 >
  - 이벤트가 특정 레벨을 유지하는 동안 계속 해서 반응
  - 특정 이벤트가 특정 조건을 충족한 상태에서 계속 처리
- < 데이터의 상태를 지속적으로 모니터링 해야함 >
  - 이벤트 지속성이 중요한 경우
  - 레벨이 변경되지 않은 한 ( 소켓 버퍼가 없어지지 않은 한 ) 계속 유지
  - 하지만, 레벨이 변경하지 않기 전까지는, 특정 레벨의 이벤트를 감지하지 못하기 때문에, 일부 이벤트를 놓칠 수 있음
 
  ==> 서버 측에서, 데이터 송수신이 빈번한 경우, 더 빠른 응답을 위해, 엣지 트리거를 제공
  ==> 클라이언트 측, 데이터 송수신이 다양하지 않은 경우, 계속 데이터를 모니터링 하면서 필요한 처리를 수행하는데 더 적합
  
#### 2️⃣ 엣지 트리거
- 데이터(FD) 의 변화에 반응하는 방식
- 이벤트가 발생할 때만, 알림 발생
- 알림을 받은 이후, 이벤트 처리 / 계속 블록
- 
- 소켓
- 데이터의 도착 ( RECV )
- 연결 상태 변경과 같은 이벤트가 발생할 때만, 알림 발생

- 소켓 버퍼에 데이터가 들어오는 순간에만 이벤트 발생
-   --> t새로운 데이터가 들어와야만 이벤트 발생

- < 어떤 상황에서 유리한지 >
  - 빠른 응답이 필요한 상황 ???
    - 데이터의 변경 / 이벤트 발생 시, 즉각적으로 반응
    - 데이터의 변화가 매우 빈번하게 일어날 경우, 그 중에서 특정 엣지만 처리해야하는 경우,
      - 네트워크 부하와 데이터 처리량이 증가

==> 서버에서 유리
- Non Blocking I/O 소켓을 변경
  * 엣지 트리거는 데이터 수신 시, 한번만 이벤트가 발생되기 떄문에, << 충분한 양의 버퍼를 마련한 다음 >> , 데이터를 읽어 들여야 함
  * 
  
