### Ⅰ. 메모리 풀 (Memory Pool)
#### 0️⃣ 메모리 풀
✅ 배경
- 동적 할당
  - 종류
    - ( malloc / free ) : struct 구조체 사용 --> malloc + memset + (( free ))
    - ( new / delete )  : 클래스 사용 --> (( 클래스는 memset 하지 않기 ))
  - (( 다양한 Block Size )) ( 동적 할당 ) 으로 인하여, 단편화 유발
  - 파편화된 메모리들은 Performance 때문에 실시간 시스템에서 사용할 수 없음
  - 성능을 저하 시킴
    - [할당]  (malloc/new) → 운영체제 커널 요청 → 메모리 할당
    - [해제] (free/delete) → 운영체제 커널 요청 → 메모리 해제
    - ▫ 반복적인 동적 할당은 (( 사용자 영역 코드 )) ↔ (( 커널 영역 )) 을 전환 (시스템 전환) 이 많아지기 때문에 성능이 저하된다.
    - ▫ ( free / delete ) 를 못할 경우, 메모리 릭이 발생하여, 점유하는 메모리 영역이 증가해, 성능 저하를 발생
    - ▫ ( free / delete ) 를 못할 경우, 점유하는 메모리 영역이 증가하여, 메모리가 귀해져서, 하드디스크를 참조하게 되고, 이는 성능 저하를 발생시킴
 
✅ 메모리 풀
- 고정된 크기의 Block 을 미리 할당 하여, malloc / new 연산을 통해 유사한 메모리 동적 할당을 가능하게 해줌
  - 미리 Block 을 할당 해줌으로써, 계속적으로 커널 시스템 모드로 전환을 할 필요가 없다
    - 고정된 크기의 Block 할당 : ( 고정된 크기, 메모리 재사용, 파편화 X ) → Cache 효율성이 좋다
  - 유사한 메모리 동적 할당 기능을 가능하게 하여, 실행 시간 ( Run-time ) 에 handle 에 의해서 표현되는 블록들을 할당하고 접근한다.
 
✅ 배경 지식
- 메모리 종류
  - (1). 고정 메모리
    - 고정된 크기   : 고정 크기의 Block 을 갖는 메모리 관리자
    - 메모리 재사용 : 반환된 메모리의 (( 효율적인 재사용 ))
    - 파편화 X     : (( 동일한 크기의 Block )) 을 요청하기 때문에 파편화 발생 X
      - ▫ 내부 단편화 X : 고정된 크기 할당으로 내부 단편화 발생 안함
      - ▫ 외부 단편화 X : 미리 외부에서 할당 받은 공간에 메모리 할당 / 해제를 하기 때문에 외부 단변화 발생 안함
    - Cache 효율성 : 고정된 크기의 Block 을 갖는 메모리 관리자는 (( Cache 효율 )) 이 좋다.
   
  - (2). 가변 메모리

✅ 목표
- 고정된 크기
- 메모리 재사용
- 파편화 X
- Cache 효율성
- 속력 향상
  - 컴파일러가 제공하는 할당자보다 속력이 더 빨라야 한다
  - 미리 할당해놓고 가져다가 사용하기 때문에, 잦은 시스템 전환을 막을 수 있어 속력 향상
- 안정성
  - 프로그램 종료 이전, 메모리 누수 방지  

#### 3️⃣ 기타
✅ 문자열
```cpp
char* temp = new char[10];
memcpy(temp, "1234567890", 10);
temp[5] = 0

printf("결과: %s\n", temp); // 12345
```
- temp[5] = **0** || temp[5] = **'\0'** : 문자의 끝을 의미
- 따라서, memset(temp, 0, 10); 할 때, 주의 → 모든 char 문자열들을 ( 문자의 끝 )으로 만들고 시작하는 것을 뜻함
